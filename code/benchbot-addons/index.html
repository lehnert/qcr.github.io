<!DOCTYPE html><html><head><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-H0HTWHNLPD"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-H0HTWHNLPD', {
              page_path: window.location.pathname,
            });
          </script><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QUT Centre for Robotics Open Source</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/ec58676f2add16c92212.css" as="style"/><link rel="stylesheet" href="/_next/static/css/ec58676f2add16c92212.css" data-n-g=""/><link rel="preload" href="/_next/static/css/e59d3ff98fad3f065f44.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e59d3ff98fad3f065f44.css" data-n-p=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/main-c439d75cfca1ce6a0f7f.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.a6402fb70cc88f6f61b0.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.455c36b53add9c9c2736.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-d07085bfa8b88c39a473.js" as="script"/><link rel="preload" href="/_next/static/chunks/3d04e185781834a6bdd2cdc78a14cbdede4fee55.e5e850c413858c1cae6e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/code/%5Bcode%5D-855919f7a7c9635db067.js" as="script"/></head><body><div id="__next"><div class="site" style="--mdc-theme-on-primary:rgba(255, 255, 255, 1);--mdc-theme-primary:#00407a"><header class="top_bar_bar__3T8Pf mdc-top-app-bar"><div class="top_bar_row__2Br8o mdc-top-app-bar__row"><section class="top_bar_logo-section__-bkhv mdc-top-app-bar__section mdc-top-app-bar__section--align-start"><img class="top_bar_logo__27Lwl" alt="QCR Logo (light)" src="/_next/static/images/qcr_logo_light-3a0967f7c1a32ca7de4713af85481529.png"/></section><section class="top_bar_pages__3emYr mdc-top-app-bar__section mdc-top-app-bar__section--align-end"><button class="mdc-button"><div class="mdc-button__ripple"></div><span class="mdc-button__label">Collections</span></button><button class="top_bar_selected-tab__2hCGV mdc-button"><div class="mdc-button__ripple"></div><span class="mdc-button__label">Code</span></button><button class="mdc-button"><div class="mdc-button__ripple"></div><span class="mdc-button__label">Datasets</span></button></section></div></header><div class="layout_space__3mcnW"></div><div class="layout_main__1OEEk layout_content__3ZRgy"><span class="code_heading__1xc27 mdc-typography--headline3">BenchBot Add-ons Manager</span><a href="https://github.com/qcr/benchbot_addons" target="_blank" class="focus_button_link__3dooQ"><button class="focus_button_button__MO_3J mdc-button mdc-button--raised"><div class="mdc-button__ripple"></div><span class="mdc-button__label">View the code on GitHub</span><i class="rmwc-icon rmwc-icon--url material-icons mdc-button__icon" style="background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iZ2l0aHViLnN2ZyIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMS4wICgxLjArcjczKzEpIgogICBpZD0ic3ZnMTM4MyIKICAgdmVyc2lvbj0iMS4xIgogICB2aWV3Qm94PSIwIDAgMTEuNDkzMTQ3IDExLjIwOTQ2NyIKICAgaGVpZ2h0PSIxMS4yMDk0NjdtbSIKICAgd2lkdGg9IjExLjQ5MzE0N21tIj4KICA8ZGVmcwogICAgIGlkPSJkZWZzMTM3NyIgLz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIKICAgICBpbmtzY2FwZTp3aW5kb3cteT0iMzYyIgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwNTIiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBpbmtzY2FwZTpkb2N1bWVudC1yb3RhdGlvbj0iMCIKICAgICBpbmtzY2FwZTpjdXJyZW50LWxheWVyPSJsYXllcjEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9Im1tIgogICAgIGlua3NjYXBlOmN5PSIxMjYuMjk1MTUiCiAgICAgaW5rc2NhcGU6Y3g9IjE4Ljk2OTk1MSIKICAgICBpbmtzY2FwZTp6b29tPSIwLjk4ODg0NzEiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMC4wIgogICAgIGJvcmRlcm9wYWNpdHk9IjEuMCIKICAgICBib3JkZXJjb2xvcj0iIzY2NjY2NiIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgaWQ9ImJhc2UiIC8+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhMTM4MCI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTAxLjMyMzAzLC05OC4yMTQ5NTkpIgogICAgIGlkPSJsYXllcjEiCiAgICAgaW5rc2NhcGU6Z3JvdXBtb2RlPSJsYXllciIKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSI+CiAgICA8ZwogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC4zNTI3Nzc3NywwLDAsLTAuMzUyNzc3NzcsMTA3LjA2OTA3LDk4LjIxNDk1OSkiCiAgICAgICBpZD0iZzIyIj4KICAgICAgPHBhdGgKICAgICAgICAgaWQ9InBhdGgyNCIKICAgICAgICAgc3R5bGU9ImZpbGw6IzFiMTgxNztmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2U6bm9uZSIKICAgICAgICAgZD0ibSAwLDAgYyAtOC45OTUsMCAtMTYuMjg4LC03LjI5MyAtMTYuMjg4LC0xNi4yOSAwLC03LjE5NyA0LjY2NywtMTMuMzAyIDExLjE0LC0xNS40NTcgMC44MTUsLTAuMTQ5IDEuMTEyLDAuMzU0IDEuMTEyLDAuNzg2IDAsMC4zODYgLTAuMDE0LDEuNDExIC0wLjAyMiwyLjc3IC00LjUzMSwtMC45ODQgLTUuNDg3LDIuMTg0IC01LjQ4NywyLjE4NCAtMC43NDEsMS44ODEgLTEuODA5LDIuMzgyIC0xLjgwOSwyLjM4MiAtMS40NzksMS4wMTEgMC4xMTIsMC45OTEgMC4xMTIsMC45OTEgMS42MzUsLTAuMTE2IDIuNDk1LC0xLjY3OSAyLjQ5NSwtMS42NzkgMS40NTMsLTIuNDg5IDMuODEzLC0xLjc3IDQuNzQxLC0xLjM1NCAwLjE0OCwxLjA1MyAwLjU2OCwxLjc3MSAxLjAzNCwyLjE3OCAtMy42MTcsMC40MTEgLTcuNDIsMS44MDkgLTcuNDIsOC4wNTEgMCwxLjc3OCAwLjYzNSwzLjIzMiAxLjY3Nyw0LjM3MSAtMC4xNjgsMC40MTIgLTAuNzI3LDIuMDY4IDAuMTU5LDQuMzExIDAsMCAxLjM2OCwwLjQzOCA0LjQ4LC0xLjY3IDEuMjk5LDAuMzYxIDIuNjkzLDAuNTQyIDQuMDc4LDAuNTQ4IDEuMzgzLC0wLjAwNiAyLjc3NywtMC4xODcgNC4wNzgsLTAuNTQ4IDMuMTEsMi4xMDggNC40NzUsMS42NyA0LjQ3NSwxLjY3IDAuODg5LC0yLjI0MyAwLjMzLC0zLjg5OSAwLjE2MiwtNC4zMTEgMS4wNDQsLTEuMTM5IDEuNjc1LC0yLjU5MyAxLjY3NSwtNC4zNzEgMCwtNi4yNTggLTMuODA5LC03LjYzNSAtNy40MzgsLTguMDM4IDAuNTg1LC0wLjUwMyAxLjEwNiwtMS40OTcgMS4xMDYsLTMuMDE3IDAsLTIuMTc3IC0wLjAyLC0zLjkzNCAtMC4wMiwtNC40NjggMCwtMC40MzYgMC4yOTMsLTAuOTQzIDEuMTIsLTAuNzg0IDYuNDY4LDIuMTU5IDExLjEzMSw4LjI2IDExLjEzMSwxNS40NTUgQyAxNi4yOTEsLTcuMjkzIDguOTk3LDAgMCwwIiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg==)"></i></button></a><span class="code_extra__yQqAk mdc-typography--body2">qcr/benchbot_addons</span><span class="markdown-body mdc-typography--body1"><div><p><strong>NOTE: this software is part of the BenchBot software stack, and not intended to be run in isolation (although it can be installed independently through pip if desired). For a working BenchBot system, please install the BenchBot software stack by following the instructions <a href=https://github.com/qcr/benchbot>here</a>.</strong></p>
<h1>BenchBot Add-ons Manager</h1>
<p><video autoplay loop poster="/_next/static/gifs/8ef442bbcf06f5d9f4a4bd553bd28212.jpg"><source src="/_next/static/gifs/8ef442bbcf06f5d9f4a4bd553bd28212.webm" type="video/webm"/></video></p>
<p>The BenchBot Add-ons Manager allows you to use BenchBot with a wide array of additional content, and customise your installation to suite your needs. Semantic Scene Understanding not your thing? Install the Semantic Question Answering add-ons instead. Want to create your own content? Write some basic YAML files to make your own add-ons. Need to re-use existing content? Simply include a dependency on that add-on. Add-ons are all about making BenchBot whatever you need it to be—build a BenchBot for your research problems, exactly as you need it.</p>
<p>Add-ons come in a variety of types. Anything that you may need to customise for your own experiments or research, should be customisable through an add-on. If not, let us know, and we'll add more add-on enabled functionality to BenchBot!</p>
<p>The list of currently supported types of add-ons are:</p>
<ul>
<li><strong>batches</strong>: a list of environments used for repeatable evaluation scores with the <code class="language-none">benchbot_batch</code> script.</li>
<li><strong>environments</strong>: simulated or real world environments that a task can be performed in, with a robot. Only <a href="https://developer.nvidia.com/Isaac-sim">Isaac Sim</a> simulation is currently supported, but there is capacity to support other simulators. Please get in contact if you'd like to see another simulator in BenchBot!</li>
<li><strong>evaluation_methods</strong>: a method for evaluating a set of formatted results, against a corresponding ground truth, and producing scores describing how well a result performed a given task.</li>
<li><strong>formats</strong>: formalisation of a format for results or ground truth data, including helper functions.</li>
<li><strong>ground_truths</strong>: ground truth data in a declared format, about a specific environment. Environments can have many different types of ground truths depending on what different tasks require.</li>
<li><strong>robots</strong>: a robot definition declaring the communication channels available to the BenchBot ecosystem. Both simulated and real world robots are supported, they just need to run ROS.</li>
<li><strong>tasks</strong>: a task is a definition of something we want a robot to do, including what observations and actions it has available, and how results should be reported.</li>
</ul>
<p>See the sections below for details of how to interact with installed add-ons, how to create your own add-ons, and formalisation of what's required in an add-on.</p>
<h2>Installing and using the add-ons manager</h2>
<p>In general, you won't use the add-ons manager directly. Instead you interact with the <a href=https://github.com/qcr/benchbot>BenchBot software stack</a>, which uses the add-ons manager to manage and access add-ons.</p>
<p>The manager is a Python package if you do find you want to use it directly, and installable with pip. Run the following in the root directory where the repository was cloned:</p>
<pre class="language-none"><code class="language-none">u@pc:~$ pip install .
</code></pre>
<p>The manager can then be imported and used to manage installation, loading, accessing, processing, and updating of add-ons. Some samples of supported functionality are shown below:</p>
<pre class="language-python"><code class="language-python"><span class="token keyword">from</span> benchbot_addons <span class="token keyword">import</span> manager <span class="token keyword">as</span> bam

<span class="token comment"># Check if example with 'name' = 'hello_scd' exists</span>
bam<span class="token punctuation">.</span>exists<span class="token punctuation">(</span><span class="token string">'examples'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'hello_scd'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># Find all installed environments</span>
bam<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'environments'</span><span class="token punctuation">)</span>

<span class="token comment"># Get a list of the names for all installed tasks</span>
bam<span class="token punctuation">.</span>get_field<span class="token punctuation">(</span><span class="token string">'tasks'</span><span class="token punctuation">,</span> <span class="token string">'name'</span><span class="token punctuation">)</span>

<span class="token comment"># Get a list of (name, variant) pairs for all installed environments</span>
bam<span class="token punctuation">.</span>get_fields<span class="token punctuation">(</span><span class="token string">'environments'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'variant'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># Find a robot with 'name' = 'carter'</span>
bam<span class="token punctuation">.</span>get_match<span class="token punctuation">(</span><span class="token string">'robots'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">'name'</span><span class="token punctuation">,</span> <span class="token string">'carter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># Get the 'results_format' value for the task called 'scd:passive:ground_truth'</span>
bam<span class="token punctuation">.</span>get_value_by_name<span class="token punctuation">(</span><span class="token string">'tasks'</span><span class="token punctuation">,</span> <span class="token string">'scd:passive:ground_truth'</span><span class="token punctuation">,</span> <span class="token string">'results_format'</span><span class="token punctuation">)</span>

<span class="token comment"># Load YAML data for all installed ground truths</span>
bam<span class="token punctuation">.</span>load_yaml_list<span class="token punctuation">(</span>bam<span class="token punctuation">.</span>find_all<span class="token punctuation">(</span><span class="token string">'ground_truths'</span><span class="token punctuation">,</span> extension<span class="token operator">=</span><span class="token string">'json'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment"># Install a list of comma-separated add-ons</span>
bam<span class="token punctuation">.</span>install_addons<span class="token punctuation">(</span><span class="token string">'benchbot-addons/ssu,benchbot-addons/sqa'</span><span class="token punctuation">)</span>

<span class="token comment"># Install a specific add-on (&amp; it's dependencies)</span>
bam<span class="token punctuation">.</span>install_addon<span class="token punctuation">(</span><span class="token string">'tasks_ssu'</span><span class="token punctuation">)</span>

<span class="token comment"># Print the list of currently installed add-ons, &amp; officially available add-ons</span>
bam<span class="token punctuation">.</span>print_state<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Uninstall all add-ons</span>
bam<span class="token punctuation">.</span>remove_addons<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Uninstall a string separated list of add-ons</span>
bam<span class="token punctuation">.</span>remove_addon<span class="token punctuation">(</span><span class="token string">'benchbot-addons/ssu,benchbot-addons/sqa'</span><span class="token punctuation">)</span>
</code></pre>
<h2>How to add your own add-ons</h2>
<p>There are two different types of add-ons: 'official' add-ons and third-party add-ons.</p>
<p>'Official' are add-ons that we've verified, and are stored in our <a href=https://github.com/benchbot-addons>benchbot-addons</a> GitHub organisation. You can get a full list of official add-ons through the <code class="language-none">manager.official_addons()</code> helper function, or <code class="language-none">benchbot_install --list-addons</code> script in the <a href=https://github.com/qcr/benchbot>BenchBot software stack</a>.</p>
<p>Third-party add-ons only differ in that we haven't looked at them, and they can be hosted anywhere on GitHub you please.</p>
<p>Creating all add-ons is exactly the same process, the only difference is whether the repository is inside or outside of the <a href=https://github.com/benchbot-addons>benchbot-addons</a> GitHub organisation:</p>
<ol>
<li>Create a new GitHub repository</li>
<li>Add folders corresponding to the type of content your add-ons provide (i.e. an environments add-on has an <code class="language-none">environments</code> directory at the root).</li>
<li>Add YAML / JSON files for your content, and make sure they match the corresponding format specification from the section below</li>
<li>Add in any extra content your add-on may require: Python files, simulator binaries, images, etc. (if your add-on gets too big for a Git repository, you can zip the content up, host it somewhere, and use the <code class="language-none">.remote</code> metadata file described in the next section)</li>
<li>Decide if your add-on is dependent on any others, and declare any dependencies in a <code class="language-none">.dependencies</code> file</li>
<li>Push everything up to git on your default branch</li>
</ol>
<p><em><strong>Note:</strong> it's a good idea to only include one type of add-on per repository as it makes your add-on package more usable for others. It's not a hard rule though, so feel free to add multiple folders to your add-on if you require.</em></p>
<p>Feel free to have a look at any of the <a href=https://github.com/benchbot-addons>official add-ons</a> for help and examples of how to work with add-ons.</p>
<h2>Add-ons format specification</h2>
<p>Here are the technical details of what's expected in add-on content. The BenchBot system will assume these specifications are adhered to, and errors can be expected if you try to use add-ons that don't match the specifications.</p>
<p>An add-on package has the following structure (technically none of the files are required, they just determine what functionality your add-on includes):</p>
<table>
<thead>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">.dependencies</code></td>
<td>A list of add-on packages that must be installed with this package. Packages are specified by their GitHub identifier (i.e. <code class="language-none">github_username/repository_name</code>), with one per line</td>
</tr>
<tr>
<td><code class="language-none">.dependencies-python</code></td>
<td>A list of Python dependencies for your add-on. Syntax for file is exactly the same as <a href="https://pip.pypa.io/en/stable/user_guide/#requirements-files"><code class="language-none">requirements.txt</code></a> files.</td>
</tr>
<tr>
<td><code class="language-none">.remote</code></td>
<td>Specifies content that should be installed from a remote URL, rather than residing in this repository. A remote resource is specified as a URL and target directory separated by a space. One resource is specified per line. The add-ons manager will fetch the URL specified, and extract the contents to the target directory (e.g. <code class="language-none">http://myhost/my_content.zip environments</code>)</td>
</tr>
<tr>
<td><code class="language-none">&lt;directory&gt;/</code></td>
<td>Each named directory corresponds to an add-on type described below. The directory will be ignored if its name doesn't exactly match any of those below.</td>
</tr>
</tbody>
</table>
<h3>Batch add-ons</h3>
<p>A YAML file, that must exist in a folder called <code class="language-none">batches</code> in the root of the add-on package (e.g. <code class="language-none">batches/my_batch.yaml</code>).</p>
<p>The following keys are supported for batch add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'name'</code></td>
<td>Yes</td>
<td>A string used to refer to this batch (must be unique!).</td>
</tr>
<tr>
<td><code class="language-none">'environments'</code></td>
<td>Yes</td>
<td>A list of environment strings of the format <code class="language-none">'name':'variant'</code> (e.g. <code class="language-none">'miniroom:1'</code>).</td>
</tr>
</tbody>
</table>
<h3>Environment add-ons</h3>
<p>A YAML file, that must exist in a folder called <code class="language-none">environments</code> in the root of the add-on package (e.g. <code class="language-none">environments/my_environment.yaml</code>).</p>
<p>The following keys are supported for environment add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'name'</code></td>
<td>Yes</td>
<td>A string used to refer to this environment's name (the <code class="language-none">('name', 'variant')</code> pair must be unique!).</td>
</tr>
<tr>
<td><code class="language-none">'variant'</code></td>
<td>Yes</td>
<td>A string used to refer to this environment's variant (the <code class="language-none">('name', 'variant')</code> pair must be unique!).</td>
</tr>
<tr>
<td><code class="language-none">'type'</code></td>
<td>Yes</td>
<td>A string describing the type of this environment (<code class="language-none">'sim_unreal'</code> &amp; <code class="language-none">'real'</code> are the only values currently used).</td>
</tr>
<tr>
<td><code class="language-none">'map_path'</code></td>
<td>Yes</td>
<td>A path to the map for this environment, which will be used by either the simulator or real world system to load the environment.</td>
</tr>
<tr>
<td><code class="language-none">'start_pose'</code></td>
<td>Yes</td>
<td>The start pose of the robot that will be provided to users through the <a href=https://github.com/qcr/benchbot_api>BenchBot API</a>. The pose is specified as a list of 7 numbers: quarternion_x, quarternion_y, quarternion_z, quarternion_w, position_x, position_y, position_z. This must be accurate!</td>
</tr>
<tr>
<td><code class="language-none">'trajectory_poses'</code></td>
<td>No</td>
<td>A list of poses for the robot to traverse through in order. Each pose is a list of 7 numbers: quarternion_x, quarternion_y, quarternion_z, quarternion_w, position_x, position_y, position_z. This environment won't be usable for tasks that use the <code class="language-none">'move_next'</code> action if this parameter isn't provided.</td>
</tr>
<tr>
<td><code class="language-none">'robots'</code></td>
<td>No</td>
<td>A list of supported names for robot that are supported in this environment. If this list isn't included, all robots with the same <code class="language-none">'type'</code> as this environment will be able to run.</td>
</tr>
<tr>
<td><code class="language-none">'object_labels'</code></td>
<td>No</td>
<td>A list of labels for the objects that exist in the scene. Can be used with simulated sensors like segmentation sensors.</td>
</tr>
</tbody>
</table>
<h3>Evaluation method add-ons</h3>
<p>A YAML file, that must exist in a folder called <code class="language-none">evaluation_methods</code> in the root of the add-on package (e.g. <code class="language-none">evaluation_methods/my_evaluation_method.yaml</code>).</p>
<p>The following keys are supported for evaluation method add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'name'</code></td>
<td>Yes</td>
<td>A string used to refer to this evaluation method (must be unique!)</td>
</tr>
<tr>
<td><code class="language-none">'valid_result_formats'</code></td>
<td>Yes</td>
<td>List of strings denoting results formats supported by the evaluation method. Ideally these format definitions should also be installed.</td>
</tr>
<tr>
<td><code class="language-none">'valid_ground_truth_formats'</code></td>
<td>Yes</td>
<td>List of strings denoting ground truth formats supported by the evaluation method. Ideally these format definitions should also be installed.</td>
</tr>
<tr>
<td><code class="language-none">'functions'</code></td>
<td>Yes</td>
<td>Dictionary of named functions provided by the evaluation method. The named methods are key value pairs where the key is the function name, and the value is a string describing how the function can be imported with Python. For example, <code class="language-none">evaluate: &quot;omq.evaluate_method&quot;</code> declares a function called <code class="language-none">'evaluate'</code> that is imported via <code class="language-none">from omq import evaluate_method</code>. Likewise <code class="language-none">&quot;omq.submodule.combine_method&quot;</code> translates to <code class="language-none">from omq.submodule import combine_method</code>. See below for the list of functions expected for evaluation methods.</td>
</tr>
<tr>
<td><code class="language-none">'description'</code></td>
<td>No</td>
<td>A string describing what the evaluation method is and how it works. Should be included if you want users to understand where your method can be used.</td>
</tr>
</tbody>
</table>
<p>Evaluation methods expect the following named functions:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Signature</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'evaluate'</code></td>
<td><code class="language-none">fn(dict: results, list: ground_truths) -&gt; dict</code></td>
<td>Evaluates the performance using a <code class="language-none">results</code> dictionary, and returns a dictionary of containing the scores. It also takes a list of dictionaries containing each ground truth that will be used in evaluation.</td>
</tr>
<tr>
<td><code class="language-none">'combine'</code></td>
<td><code class="language-none">fn(list: scores) -&gt; dict</code></td>
<td>Takes a list of <code class="language-none">scores</code> dictionaries, and returns an aggregate score. If this method isn't declared, <a href=https://github.com/qcr/benchbot_eval><code class="language-none">benchbot_eval</code></a> won't return a summary score.</td>
</tr>
</tbody>
</table>
<h3>Format definition add-ons</h3>
<p>A YAML file, that must exist in a folder called <code class="language-none">formats</code> in the root of the add-on package (e.g. <code class="language-none">formats/my_format.yaml</code>).</p>
<p>The following keys are supported for format add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'name'</code></td>
<td>Yes</td>
<td>A string used to refer to this format (must be unique!)</td>
</tr>
<tr>
<td><code class="language-none">'functions'</code></td>
<td>Yes</td>
<td>Dictionary of named functions for use with this format. The named methods are key-value pairs where the key is the function name, and the value is a string describing how the function can be imported with Python. For example, <code class="language-none">create: &quot;object_map.create_empty&quot;</code> declares a function called <code class="language-none">'create'</code> that is imported via <code class="language-none">from object_map import create_empty</code>. Likewise <code class="language-none">&quot;object_map.submodule.validate&quot;</code> translates to <code class="language-none">from object_map.submodule import validate</code>. See below for the list of functions expected for format definitions.</td>
</tr>
<tr>
<td><code class="language-none">'description'</code></td>
<td>No</td>
<td>A string describing what the format is and how it works. Should be included if you want users to understand what your format is supposed to capture.</td>
</tr>
</tbody>
</table>
<p>Format definitions expect the following named functions:</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Signature</th>
<th>Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'create'</code></td>
<td><code class="language-none">fn() -&gt; dict</code></td>
<td>Function that returns an empty instance of this format. As much as possible should be filled in to make it easy for users to create valid instances (especially when a format is used for results).</td>
</tr>
<tr>
<td><code class="language-none">'validate'</code></td>
<td><code class="language-none">fn(dict: instance) -&gt; None</code></td>
<td>Takes a proposed <code class="language-none">instance</code> of this format and validates whether it meets the requirements. Will typically use a series of assert statements to confirm fields are valid.</td>
</tr>
</tbody>
</table>
<h3>Ground truth add-ons</h3>
<p>A JSON file, that must exist in a folder called <code class="language-none">ground_truths</code> in the root of the add-on package (e.g. <code class="language-none">ground_truths/my_ground_truth.json</code>).</p>
<p>The following keys are supported for ground truth add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'environment'</code></td>
<td>Yes</td>
<td>A dictionary containing the definition data for the ground truth's reference environment. The data in this field should be a direct copy of an environment add-on.</td>
</tr>
<tr>
<td><code class="language-none">'format'</code></td>
<td>Yes</td>
<td>A dictionary containing the definition data for the ground truth's format. The data in this field should be a direct copy of a format definition add-on.</td>
</tr>
<tr>
<td><code class="language-none">'ground_truth'</code></td>
<td>Yes</td>
<td>A valid instance of the format described by the <code class="language-none">'format'</code> field. This is where your actual ground truth data should be stored.</td>
</tr>
</tbody>
</table>
<p>A lot of these keys should be copied from other valid definitions. Please see the <code class="language-none">GroundTruthCreator</code> helper class in <a href=https://github.com/qcr/benchbot_eval>BenchBot Evaluation</a> for assistance in creating valid ground truths.</p>
<h3>Robot add-ons</h3>
<p>A YAML file, that must exist in a folder called <code class="language-none">robots</code> in the root of the add-on package (e.g. <code class="language-none">robots/my_robot.yaml</code>).</p>
<p>The following keys are supported for robot add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'name'</code></td>
<td>Yes</td>
<td>A string used to refer to this robot (must be unique!).</td>
</tr>
<tr>
<td><code class="language-none">'type'</code></td>
<td>Yes</td>
<td>A string describing the type of this robot (<code class="language-none">'sim_unreal'</code> &amp; <code class="language-none">'real'</code> are the only values currently used).</td>
</tr>
<tr>
<td><code class="language-none">'address'</code></td>
<td>Yes</td>
<td>A string for the address where a running <a href=https://github.com/qcr/benchbot_robot_controller>BenchBot Robot Controller</a> can be accessed (e.g. <code class="language-none">'localhost:10000'</code>)</td>
</tr>
<tr>
<td><code class="language-none">'global_frame'</code></td>
<td>Yes</td>
<td>The name of the global TF frame. All poses reported by the <a href=https://github.com/qcr/benchbot_api>BenchBot API</a> will be with respect to this frame.</td>
</tr>
<tr>
<td><code class="language-none">'robot_frame'</code></td>
<td>Yes</td>
<td>The name of the robot's TF frame.</td>
</tr>
<tr>
<td><code class="language-none">'poses'</code></td>
<td>Yes</td>
<td>A list of named poses that this robot provides. This list of poses will be available in observations provided by the <a href=https://github.com/qcr/benchbot_api>BenchBot API</a>.</td>
</tr>
<tr>
<td><code class="language-none">'start_cmds'</code></td>
<td>Yes</td>
<td>A list of commands describing how to start the robot (this will often include the simulator). The commands will be run in parallel, and executed via <code class="language-none">bash -c '&lt;your_command_string&gt;'</code></td>
</tr>
<tr>
<td><code class="language-none">'connections'</code></td>
<td>Yes</td>
<td>A dictionary of connections that your robot makes available to the BenchBot ecosystem. The name of the key-value pair is important, and should follow the recommendations provided on standard channels in the <a href=https://github.com/qcr/benchbot_api>BenchBot API documentation</a>. A description of connection definitions is provided below.</td>
</tr>
</tbody>
</table>
<p>Connections are the lifeblood of interaction between BenchBot and robot platforms. They are defined by named entries, with the following fields:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'connection'</code></td>
<td>Yes</td>
<td>Connection type string, used by the <a href=https://github.com/qcr/benchbot_robot_controller>BenchBot Robot Controller</a>. Supported values are <code class="language-none">'api_to_ros'</code> (used for actions), <code class="language-none">'ros_to_api'</code> (used for observations), and <code class="language-none">'roscache_to_api'</code> (special value used for caching observation values).</td>
</tr>
<tr>
<td><code class="language-none">'ros_topic'</code></td>
<td>Yes</td>
<td>Topic name for the ROS side of the connection.</td>
</tr>
<tr>
<td><code class="language-none">'ros_type'</code></td>
<td>Yes</td>
<td>Topic type for the ROS side of the connection.</td>
</tr>
<tr>
<td><code class="language-none">'callback_api'</code></td>
<td>No</td>
<td>A callback that is run on the HTTP encoded data received / sent on the API end of the connection. It takes in data, and returns transformed data based on the callback's action. Callbacks are specified by a string denoting how the callback can be accessed (e.g. <code class="language-none">'api_callbacks.convert_to_rgb</code> = <code class="language-none">from api_callbacks import convert_to_rgb</code>). No data transformation occurs if no callback is provided.</td>
</tr>
<tr>
<td><code class="language-none">'callback_ros'</code></td>
<td>No</td>
<td>A callback that is run on the ROS data received / sent on the robot controller end of the connection. It takes in data and a reference to the robot controller. <code class="language-none">'api_to_ros'</code> connections use this data to act on the robot, whereas <code class="language-none">'ros_to_api'</code> connections turn this data into a dictionary that can be serialised into HTTP traffic. Callbacks are specified by a string denoting how the callback can be accessed (e.g. <code class="language-none">'api_callbacks.convert_to_rgb</code> = <code class="language-none">from api_callbacks import convert_to_rgb</code>). No action occurs at the ROS level if no callback is provided.</td>
</tr>
</tbody>
</table>
<h3>Task add-ons</h3>
<p>A YAML file, that must exist in a folder called <code class="language-none">tasks</code> in the root of the add-on package (e.g. <code class="language-none">tasks/my_task.yaml</code>).</p>
<p>The following keys are supported for task add-ons:</p>
<table>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code class="language-none">'name'</code></td>
<td>Yes</td>
<td>A string used to refer to this task (must be unique!).</td>
</tr>
<tr>
<td><code class="language-none">'actions'</code></td>
<td>Yes</td>
<td>A list of named connections to be provided as actions through the <a href=https://github.com/qcr/benchbot_api>BenchBot API</a>. Running this task will fail if the robot doesn't provide these named connections.</td>
</tr>
<tr>
<td><code class="language-none">'observations'</code></td>
<td>Yes</td>
<td>A list of named connections to be provided as observations through the <a href=https://github.com/qcr/benchbot_api>BenchBot API</a>. Running this task will fail if the robot doesn't provide these named connections.</td>
</tr>
<tr>
<td><code class="language-none">'results_format'</code></td>
<td>Yes</td>
<td>A string naming the format for results. The format must be installed, as <a href=https://github.com/qcr/benchbot_api>BenchBot API</a> will use the format's functions to provide the user with empty results.</td>
</tr>
<tr>
<td><code class="language-none">'description'</code></td>
<td>No</td>
<td>A string describing what the task is, and how it works. Should be included if you want users to understand what challenges your task is trying to capture.</td>
</tr>
<tr>
<td><code class="language-none">'type'</code></td>
<td>No</td>
<td>A string describing what robot / environment types are valid for this task. For example, a task that provides a magic image segmentation sensor would only be made available for <code class="language-none">'sim_unreal'</code> type robots / environments.</td>
</tr>
<tr>
<td><code class="language-none">'scene_count'</code></td>
<td>No</td>
<td>Integer representing the number of scenes (i.e. environment variations required for a task). If omitted, a default value of 1 will be used for the task.</td>
</tr>
</tbody>
</table>
</div> </span></div><div class="bottom_bar_bar__B7RGm"><div class="site-bottom-bar bottom_bar_content__2DVtD"><div></div><div></div><div><span class="mdc-typography--body2">CRICOS No. 00213J</span></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"codeData":"{\"content\":\"\u003cp\u003e\u003cstrong\u003eNOTE: this software is part of the BenchBot software stack, and not intended to be run in isolation (although it can be installed independently through pip if desired). For a working BenchBot system, please install the BenchBot software stack by following the instructions \u003ca href=https://github.com/qcr/benchbot\u003ehere\u003c/a\u003e.\u003c/strong\u003e\u003c/p\u003e\\n\u003ch1\u003eBenchBot Add-ons Manager\u003c/h1\u003e\\n\u003cp\u003e\u003cvideo autoplay loop poster=\\\"/_next/static/gifs/8ef442bbcf06f5d9f4a4bd553bd28212.jpg\\\"\u003e\u003csource src=\\\"/_next/static/gifs/8ef442bbcf06f5d9f4a4bd553bd28212.webm\\\" type=\\\"video/webm\\\"/\u003e\u003c/video\u003e\u003c/p\u003e\\n\u003cp\u003eThe BenchBot Add-ons Manager allows you to use BenchBot with a wide array of additional content, and customise your installation to suite your needs. Semantic Scene Understanding not your thing? Install the Semantic Question Answering add-ons instead. Want to create your own content? Write some basic YAML files to make your own add-ons. Need to re-use existing content? Simply include a dependency on that add-on. Add-ons are all about making BenchBot whatever you need it to be—build a BenchBot for your research problems, exactly as you need it.\u003c/p\u003e\\n\u003cp\u003eAdd-ons come in a variety of types. Anything that you may need to customise for your own experiments or research, should be customisable through an add-on. If not, let us know, and we'll add more add-on enabled functionality to BenchBot!\u003c/p\u003e\\n\u003cp\u003eThe list of currently supported types of add-ons are:\u003c/p\u003e\\n\u003cul\u003e\\n\u003cli\u003e\u003cstrong\u003ebatches\u003c/strong\u003e: a list of environments used for repeatable evaluation scores with the \u003ccode class=\\\"language-none\\\"\u003ebenchbot_batch\u003c/code\u003e script.\u003c/li\u003e\\n\u003cli\u003e\u003cstrong\u003eenvironments\u003c/strong\u003e: simulated or real world environments that a task can be performed in, with a robot. Only \u003ca href=\\\"https://developer.nvidia.com/Isaac-sim\\\"\u003eIsaac Sim\u003c/a\u003e simulation is currently supported, but there is capacity to support other simulators. Please get in contact if you'd like to see another simulator in BenchBot!\u003c/li\u003e\\n\u003cli\u003e\u003cstrong\u003eevaluation_methods\u003c/strong\u003e: a method for evaluating a set of formatted results, against a corresponding ground truth, and producing scores describing how well a result performed a given task.\u003c/li\u003e\\n\u003cli\u003e\u003cstrong\u003eformats\u003c/strong\u003e: formalisation of a format for results or ground truth data, including helper functions.\u003c/li\u003e\\n\u003cli\u003e\u003cstrong\u003eground_truths\u003c/strong\u003e: ground truth data in a declared format, about a specific environment. Environments can have many different types of ground truths depending on what different tasks require.\u003c/li\u003e\\n\u003cli\u003e\u003cstrong\u003erobots\u003c/strong\u003e: a robot definition declaring the communication channels available to the BenchBot ecosystem. Both simulated and real world robots are supported, they just need to run ROS.\u003c/li\u003e\\n\u003cli\u003e\u003cstrong\u003etasks\u003c/strong\u003e: a task is a definition of something we want a robot to do, including what observations and actions it has available, and how results should be reported.\u003c/li\u003e\\n\u003c/ul\u003e\\n\u003cp\u003eSee the sections below for details of how to interact with installed add-ons, how to create your own add-ons, and formalisation of what's required in an add-on.\u003c/p\u003e\\n\u003ch2\u003eInstalling and using the add-ons manager\u003c/h2\u003e\\n\u003cp\u003eIn general, you won't use the add-ons manager directly. Instead you interact with the \u003ca href=https://github.com/qcr/benchbot\u003eBenchBot software stack\u003c/a\u003e, which uses the add-ons manager to manage and access add-ons.\u003c/p\u003e\\n\u003cp\u003eThe manager is a Python package if you do find you want to use it directly, and installable with pip. Run the following in the root directory where the repository was cloned:\u003c/p\u003e\\n\u003cpre class=\\\"language-none\\\"\u003e\u003ccode class=\\\"language-none\\\"\u003eu@pc:~$ pip install .\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003cp\u003eThe manager can then be imported and used to manage installation, loading, accessing, processing, and updating of add-ons. Some samples of supported functionality are shown below:\u003c/p\u003e\\n\u003cpre class=\\\"language-python\\\"\u003e\u003ccode class=\\\"language-python\\\"\u003e\u003cspan class=\\\"token keyword\\\"\u003efrom\u003c/span\u003e benchbot_addons \u003cspan class=\\\"token keyword\\\"\u003eimport\u003c/span\u003e manager \u003cspan class=\\\"token keyword\\\"\u003eas\u003c/span\u003e bam\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Check if example with 'name' = 'hello_scd' exists\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eexists\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'examples'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token punctuation\\\"\u003e[\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'name'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token string\\\"\u003e'hello_scd'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e]\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Find all installed environments\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003efind_all\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'environments'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Get a list of the names for all installed tasks\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eget_field\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'tasks'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token string\\\"\u003e'name'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Get a list of (name, variant) pairs for all installed environments\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eget_fields\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'environments'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token punctuation\\\"\u003e[\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'name'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token string\\\"\u003e'variant'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e]\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Find a robot with 'name' = 'carter'\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eget_match\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'robots'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token punctuation\\\"\u003e[\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'name'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token string\\\"\u003e'carter'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e]\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Get the 'results_format' value for the task called 'scd:passive:ground_truth'\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eget_value_by_name\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'tasks'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token string\\\"\u003e'scd:passive:ground_truth'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e \u003cspan class=\\\"token string\\\"\u003e'results_format'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Load YAML data for all installed ground truths\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eload_yaml_list\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003ebam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003efind_all\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'ground_truths'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e,\u003c/span\u003e extension\u003cspan class=\\\"token operator\\\"\u003e=\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'json'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Install a list of comma-separated add-ons\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003einstall_addons\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'benchbot-addons/ssu,benchbot-addons/sqa'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Install a specific add-on (\u0026amp; it's dependencies)\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003einstall_addon\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'tasks_ssu'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Print the list of currently installed add-ons, \u0026amp; officially available add-ons\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eprint_state\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Uninstall all add-ons\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eremove_addons\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\\n\u003cspan class=\\\"token comment\\\"\u003e# Uninstall a string separated list of add-ons\u003c/span\u003e\\nbam\u003cspan class=\\\"token punctuation\\\"\u003e.\u003c/span\u003eremove_addon\u003cspan class=\\\"token punctuation\\\"\u003e(\u003c/span\u003e\u003cspan class=\\\"token string\\\"\u003e'benchbot-addons/ssu,benchbot-addons/sqa'\u003c/span\u003e\u003cspan class=\\\"token punctuation\\\"\u003e)\u003c/span\u003e\\n\u003c/code\u003e\u003c/pre\u003e\\n\u003ch2\u003eHow to add your own add-ons\u003c/h2\u003e\\n\u003cp\u003eThere are two different types of add-ons: 'official' add-ons and third-party add-ons.\u003c/p\u003e\\n\u003cp\u003e'Official' are add-ons that we've verified, and are stored in our \u003ca href=https://github.com/benchbot-addons\u003ebenchbot-addons\u003c/a\u003e GitHub organisation. You can get a full list of official add-ons through the \u003ccode class=\\\"language-none\\\"\u003emanager.official_addons()\u003c/code\u003e helper function, or \u003ccode class=\\\"language-none\\\"\u003ebenchbot_install --list-addons\u003c/code\u003e script in the \u003ca href=https://github.com/qcr/benchbot\u003eBenchBot software stack\u003c/a\u003e.\u003c/p\u003e\\n\u003cp\u003eThird-party add-ons only differ in that we haven't looked at them, and they can be hosted anywhere on GitHub you please.\u003c/p\u003e\\n\u003cp\u003eCreating all add-ons is exactly the same process, the only difference is whether the repository is inside or outside of the \u003ca href=https://github.com/benchbot-addons\u003ebenchbot-addons\u003c/a\u003e GitHub organisation:\u003c/p\u003e\\n\u003col\u003e\\n\u003cli\u003eCreate a new GitHub repository\u003c/li\u003e\\n\u003cli\u003eAdd folders corresponding to the type of content your add-ons provide (i.e. an environments add-on has an \u003ccode class=\\\"language-none\\\"\u003eenvironments\u003c/code\u003e directory at the root).\u003c/li\u003e\\n\u003cli\u003eAdd YAML / JSON files for your content, and make sure they match the corresponding format specification from the section below\u003c/li\u003e\\n\u003cli\u003eAdd in any extra content your add-on may require: Python files, simulator binaries, images, etc. (if your add-on gets too big for a Git repository, you can zip the content up, host it somewhere, and use the \u003ccode class=\\\"language-none\\\"\u003e.remote\u003c/code\u003e metadata file described in the next section)\u003c/li\u003e\\n\u003cli\u003eDecide if your add-on is dependent on any others, and declare any dependencies in a \u003ccode class=\\\"language-none\\\"\u003e.dependencies\u003c/code\u003e file\u003c/li\u003e\\n\u003cli\u003ePush everything up to git on your default branch\u003c/li\u003e\\n\u003c/ol\u003e\\n\u003cp\u003e\u003cem\u003e\u003cstrong\u003eNote:\u003c/strong\u003e it's a good idea to only include one type of add-on per repository as it makes your add-on package more usable for others. It's not a hard rule though, so feel free to add multiple folders to your add-on if you require.\u003c/em\u003e\u003c/p\u003e\\n\u003cp\u003eFeel free to have a look at any of the \u003ca href=https://github.com/benchbot-addons\u003eofficial add-ons\u003c/a\u003e for help and examples of how to work with add-ons.\u003c/p\u003e\\n\u003ch2\u003eAdd-ons format specification\u003c/h2\u003e\\n\u003cp\u003eHere are the technical details of what's expected in add-on content. The BenchBot system will assume these specifications are adhered to, and errors can be expected if you try to use add-ons that don't match the specifications.\u003c/p\u003e\\n\u003cp\u003eAn add-on package has the following structure (technically none of the files are required, they just determine what functionality your add-on includes):\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eFilename\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e.dependencies\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eA list of add-on packages that must be installed with this package. Packages are specified by their GitHub identifier (i.e. \u003ccode class=\\\"language-none\\\"\u003egithub_username/repository_name\u003c/code\u003e), with one per line\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e.dependencies-python\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eA list of Python dependencies for your add-on. Syntax for file is exactly the same as \u003ca href=\\\"https://pip.pypa.io/en/stable/user_guide/#requirements-files\\\"\u003e\u003ccode class=\\\"language-none\\\"\u003erequirements.txt\u003c/code\u003e\u003c/a\u003e files.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e.remote\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eSpecifies content that should be installed from a remote URL, rather than residing in this repository. A remote resource is specified as a URL and target directory separated by a space. One resource is specified per line. The add-ons manager will fetch the URL specified, and extract the contents to the target directory (e.g. \u003ccode class=\\\"language-none\\\"\u003ehttp://myhost/my_content.zip environments\u003c/code\u003e)\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e\u0026lt;directory\u0026gt;/\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eEach named directory corresponds to an add-on type described below. The directory will be ignored if its name doesn't exactly match any of those below.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003ch3\u003eBatch add-ons\u003c/h3\u003e\\n\u003cp\u003eA YAML file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003ebatches\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003ebatches/my_batch.yaml\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for batch add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'name'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this batch (must be unique!).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'environments'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA list of environment strings of the format \u003ccode class=\\\"language-none\\\"\u003e'name':'variant'\u003c/code\u003e (e.g. \u003ccode class=\\\"language-none\\\"\u003e'miniroom:1'\u003c/code\u003e).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003ch3\u003eEnvironment add-ons\u003c/h3\u003e\\n\u003cp\u003eA YAML file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003eenvironments\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003eenvironments/my_environment.yaml\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for environment add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'name'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this environment's name (the \u003ccode class=\\\"language-none\\\"\u003e('name', 'variant')\u003c/code\u003e pair must be unique!).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'variant'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this environment's variant (the \u003ccode class=\\\"language-none\\\"\u003e('name', 'variant')\u003c/code\u003e pair must be unique!).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'type'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string describing the type of this environment (\u003ccode class=\\\"language-none\\\"\u003e'sim_unreal'\u003c/code\u003e \u0026amp; \u003ccode class=\\\"language-none\\\"\u003e'real'\u003c/code\u003e are the only values currently used).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'map_path'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA path to the map for this environment, which will be used by either the simulator or real world system to load the environment.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'start_pose'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eThe start pose of the robot that will be provided to users through the \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API\u003c/a\u003e. The pose is specified as a list of 7 numbers: quarternion_x, quarternion_y, quarternion_z, quarternion_w, position_x, position_y, position_z. This must be accurate!\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'trajectory_poses'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA list of poses for the robot to traverse through in order. Each pose is a list of 7 numbers: quarternion_x, quarternion_y, quarternion_z, quarternion_w, position_x, position_y, position_z. This environment won't be usable for tasks that use the \u003ccode class=\\\"language-none\\\"\u003e'move_next'\u003c/code\u003e action if this parameter isn't provided.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'robots'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA list of supported names for robot that are supported in this environment. If this list isn't included, all robots with the same \u003ccode class=\\\"language-none\\\"\u003e'type'\u003c/code\u003e as this environment will be able to run.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'object_labels'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA list of labels for the objects that exist in the scene. Can be used with simulated sensors like segmentation sensors.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003ch3\u003eEvaluation method add-ons\u003c/h3\u003e\\n\u003cp\u003eA YAML file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003eevaluation_methods\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003eevaluation_methods/my_evaluation_method.yaml\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for evaluation method add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'name'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this evaluation method (must be unique!)\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'valid_result_formats'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eList of strings denoting results formats supported by the evaluation method. Ideally these format definitions should also be installed.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'valid_ground_truth_formats'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eList of strings denoting ground truth formats supported by the evaluation method. Ideally these format definitions should also be installed.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'functions'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eDictionary of named functions provided by the evaluation method. The named methods are key value pairs where the key is the function name, and the value is a string describing how the function can be imported with Python. For example, \u003ccode class=\\\"language-none\\\"\u003eevaluate: \u0026quot;omq.evaluate_method\u0026quot;\u003c/code\u003e declares a function called \u003ccode class=\\\"language-none\\\"\u003e'evaluate'\u003c/code\u003e that is imported via \u003ccode class=\\\"language-none\\\"\u003efrom omq import evaluate_method\u003c/code\u003e. Likewise \u003ccode class=\\\"language-none\\\"\u003e\u0026quot;omq.submodule.combine_method\u0026quot;\u003c/code\u003e translates to \u003ccode class=\\\"language-none\\\"\u003efrom omq.submodule import combine_method\u003c/code\u003e. See below for the list of functions expected for evaluation methods.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'description'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA string describing what the evaluation method is and how it works. Should be included if you want users to understand where your method can be used.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003cp\u003eEvaluation methods expect the following named functions:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eName\u003c/th\u003e\\n\u003cth\u003eSignature\u003c/th\u003e\\n\u003cth\u003eUsage\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'evaluate'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003efn(dict: results, list: ground_truths) -\u0026gt; dict\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eEvaluates the performance using a \u003ccode class=\\\"language-none\\\"\u003eresults\u003c/code\u003e dictionary, and returns a dictionary of containing the scores. It also takes a list of dictionaries containing each ground truth that will be used in evaluation.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'combine'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003efn(list: scores) -\u0026gt; dict\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eTakes a list of \u003ccode class=\\\"language-none\\\"\u003escores\u003c/code\u003e dictionaries, and returns an aggregate score. If this method isn't declared, \u003ca href=https://github.com/qcr/benchbot_eval\u003e\u003ccode class=\\\"language-none\\\"\u003ebenchbot_eval\u003c/code\u003e\u003c/a\u003e won't return a summary score.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003ch3\u003eFormat definition add-ons\u003c/h3\u003e\\n\u003cp\u003eA YAML file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003eformats\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003eformats/my_format.yaml\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for format add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'name'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this format (must be unique!)\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'functions'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eDictionary of named functions for use with this format. The named methods are key-value pairs where the key is the function name, and the value is a string describing how the function can be imported with Python. For example, \u003ccode class=\\\"language-none\\\"\u003ecreate: \u0026quot;object_map.create_empty\u0026quot;\u003c/code\u003e declares a function called \u003ccode class=\\\"language-none\\\"\u003e'create'\u003c/code\u003e that is imported via \u003ccode class=\\\"language-none\\\"\u003efrom object_map import create_empty\u003c/code\u003e. Likewise \u003ccode class=\\\"language-none\\\"\u003e\u0026quot;object_map.submodule.validate\u0026quot;\u003c/code\u003e translates to \u003ccode class=\\\"language-none\\\"\u003efrom object_map.submodule import validate\u003c/code\u003e. See below for the list of functions expected for format definitions.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'description'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA string describing what the format is and how it works. Should be included if you want users to understand what your format is supposed to capture.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003cp\u003eFormat definitions expect the following named functions:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eName\u003c/th\u003e\\n\u003cth\u003eSignature\u003c/th\u003e\\n\u003cth\u003eUsage\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'create'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003efn() -\u0026gt; dict\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eFunction that returns an empty instance of this format. As much as possible should be filled in to make it easy for users to create valid instances (especially when a format is used for results).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'validate'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003efn(dict: instance) -\u0026gt; None\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eTakes a proposed \u003ccode class=\\\"language-none\\\"\u003einstance\u003c/code\u003e of this format and validates whether it meets the requirements. Will typically use a series of assert statements to confirm fields are valid.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003ch3\u003eGround truth add-ons\u003c/h3\u003e\\n\u003cp\u003eA JSON file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003eground_truths\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003eground_truths/my_ground_truth.json\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for ground truth add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'environment'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA dictionary containing the definition data for the ground truth's reference environment. The data in this field should be a direct copy of an environment add-on.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'format'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA dictionary containing the definition data for the ground truth's format. The data in this field should be a direct copy of a format definition add-on.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'ground_truth'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA valid instance of the format described by the \u003ccode class=\\\"language-none\\\"\u003e'format'\u003c/code\u003e field. This is where your actual ground truth data should be stored.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003cp\u003eA lot of these keys should be copied from other valid definitions. Please see the \u003ccode class=\\\"language-none\\\"\u003eGroundTruthCreator\u003c/code\u003e helper class in \u003ca href=https://github.com/qcr/benchbot_eval\u003eBenchBot Evaluation\u003c/a\u003e for assistance in creating valid ground truths.\u003c/p\u003e\\n\u003ch3\u003eRobot add-ons\u003c/h3\u003e\\n\u003cp\u003eA YAML file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003erobots\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003erobots/my_robot.yaml\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for robot add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'name'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this robot (must be unique!).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'type'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string describing the type of this robot (\u003ccode class=\\\"language-none\\\"\u003e'sim_unreal'\u003c/code\u003e \u0026amp; \u003ccode class=\\\"language-none\\\"\u003e'real'\u003c/code\u003e are the only values currently used).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'address'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string for the address where a running \u003ca href=https://github.com/qcr/benchbot_robot_controller\u003eBenchBot Robot Controller\u003c/a\u003e can be accessed (e.g. \u003ccode class=\\\"language-none\\\"\u003e'localhost:10000'\u003c/code\u003e)\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'global_frame'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eThe name of the global TF frame. All poses reported by the \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API\u003c/a\u003e will be with respect to this frame.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'robot_frame'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eThe name of the robot's TF frame.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'poses'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA list of named poses that this robot provides. This list of poses will be available in observations provided by the \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API\u003c/a\u003e.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'start_cmds'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA list of commands describing how to start the robot (this will often include the simulator). The commands will be run in parallel, and executed via \u003ccode class=\\\"language-none\\\"\u003ebash -c '\u0026lt;your_command_string\u0026gt;'\u003c/code\u003e\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'connections'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA dictionary of connections that your robot makes available to the BenchBot ecosystem. The name of the key-value pair is important, and should follow the recommendations provided on standard channels in the \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API documentation\u003c/a\u003e. A description of connection definitions is provided below.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003cp\u003eConnections are the lifeblood of interaction between BenchBot and robot platforms. They are defined by named entries, with the following fields:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'connection'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eConnection type string, used by the \u003ca href=https://github.com/qcr/benchbot_robot_controller\u003eBenchBot Robot Controller\u003c/a\u003e. Supported values are \u003ccode class=\\\"language-none\\\"\u003e'api_to_ros'\u003c/code\u003e (used for actions), \u003ccode class=\\\"language-none\\\"\u003e'ros_to_api'\u003c/code\u003e (used for observations), and \u003ccode class=\\\"language-none\\\"\u003e'roscache_to_api'\u003c/code\u003e (special value used for caching observation values).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'ros_topic'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eTopic name for the ROS side of the connection.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'ros_type'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eTopic type for the ROS side of the connection.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'callback_api'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA callback that is run on the HTTP encoded data received / sent on the API end of the connection. It takes in data, and returns transformed data based on the callback's action. Callbacks are specified by a string denoting how the callback can be accessed (e.g. \u003ccode class=\\\"language-none\\\"\u003e'api_callbacks.convert_to_rgb\u003c/code\u003e = \u003ccode class=\\\"language-none\\\"\u003efrom api_callbacks import convert_to_rgb\u003c/code\u003e). No data transformation occurs if no callback is provided.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'callback_ros'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA callback that is run on the ROS data received / sent on the robot controller end of the connection. It takes in data and a reference to the robot controller. \u003ccode class=\\\"language-none\\\"\u003e'api_to_ros'\u003c/code\u003e connections use this data to act on the robot, whereas \u003ccode class=\\\"language-none\\\"\u003e'ros_to_api'\u003c/code\u003e connections turn this data into a dictionary that can be serialised into HTTP traffic. Callbacks are specified by a string denoting how the callback can be accessed (e.g. \u003ccode class=\\\"language-none\\\"\u003e'api_callbacks.convert_to_rgb\u003c/code\u003e = \u003ccode class=\\\"language-none\\\"\u003efrom api_callbacks import convert_to_rgb\u003c/code\u003e). No action occurs at the ROS level if no callback is provided.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\u003ch3\u003eTask add-ons\u003c/h3\u003e\\n\u003cp\u003eA YAML file, that must exist in a folder called \u003ccode class=\\\"language-none\\\"\u003etasks\u003c/code\u003e in the root of the add-on package (e.g. \u003ccode class=\\\"language-none\\\"\u003etasks/my_task.yaml\u003c/code\u003e).\u003c/p\u003e\\n\u003cp\u003eThe following keys are supported for task add-ons:\u003c/p\u003e\\n\u003ctable\u003e\\n\u003cthead\u003e\\n\u003ctr\u003e\\n\u003cth\u003eKey\u003c/th\u003e\\n\u003cth\u003eRequired\u003c/th\u003e\\n\u003cth\u003eDescription\u003c/th\u003e\\n\u003c/tr\u003e\\n\u003c/thead\u003e\\n\u003ctbody\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'name'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string used to refer to this task (must be unique!).\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'actions'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA list of named connections to be provided as actions through the \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API\u003c/a\u003e. Running this task will fail if the robot doesn't provide these named connections.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'observations'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA list of named connections to be provided as observations through the \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API\u003c/a\u003e. Running this task will fail if the robot doesn't provide these named connections.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'results_format'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eYes\u003c/td\u003e\\n\u003ctd\u003eA string naming the format for results. The format must be installed, as \u003ca href=https://github.com/qcr/benchbot_api\u003eBenchBot API\u003c/a\u003e will use the format's functions to provide the user with empty results.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'description'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA string describing what the task is, and how it works. Should be included if you want users to understand what challenges your task is trying to capture.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'type'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eA string describing what robot / environment types are valid for this task. For example, a task that provides a magic image segmentation sensor would only be made available for \u003ccode class=\\\"language-none\\\"\u003e'sim_unreal'\u003c/code\u003e type robots / environments.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003ctr\u003e\\n\u003ctd\u003e\u003ccode class=\\\"language-none\\\"\u003e'scene_count'\u003c/code\u003e\u003c/td\u003e\\n\u003ctd\u003eNo\u003c/td\u003e\\n\u003ctd\u003eInteger representing the number of scenes (i.e. environment variations required for a task). If omitted, a default value of 1 will be used for the task.\u003c/td\u003e\\n\u003c/tr\u003e\\n\u003c/tbody\u003e\\n\u003c/table\u003e\\n\",\"name\":\"BenchBot Add-ons Manager\",\"type\":\"code\",\"url\":\"https://github.com/qcr/benchbot_addons\",\"src\":\"/content/benchbot/benchbot-addons.md\",\"id\":\"benchbot-addons\",\"image_position\":\"center\",\"image\":\"/_next/static/gifs/8ef442bbcf06f5d9f4a4bd553bd28212.jpg\",\"_image\":\"/_next/static/gifs/8ef442bbcf06f5d9f4a4bd553bd28212.webm\"}"},"__N_SSG":true},"page":"/code/[code]","query":{"code":"benchbot-addons"},"buildId":"1nuS-y2A2y9fnoeaTjLIs","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ff94e68042added27a93.js"></script><script src="/_next/static/chunks/main-c439d75cfca1ce6a0f7f.js" async=""></script><script src="/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/_next/static/chunks/framework.a6402fb70cc88f6f61b0.js" async=""></script><script src="/_next/static/chunks/commons.455c36b53add9c9c2736.js" async=""></script><script src="/_next/static/chunks/pages/_app-d07085bfa8b88c39a473.js" async=""></script><script src="/_next/static/chunks/3d04e185781834a6bdd2cdc78a14cbdede4fee55.e5e850c413858c1cae6e.js" async=""></script><script src="/_next/static/chunks/pages/code/%5Bcode%5D-855919f7a7c9635db067.js" async=""></script><script src="/_next/static/1nuS-y2A2y9fnoeaTjLIs/_buildManifest.js" async=""></script><script src="/_next/static/1nuS-y2A2y9fnoeaTjLIs/_ssgManifest.js" async=""></script></body></html>