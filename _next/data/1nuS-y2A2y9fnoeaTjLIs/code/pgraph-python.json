{"pageProps":{"codeData":"{\"content\":\"<h1>PGraph: simple graphs for Python</h1>\\n<p><img src=\\\"https://img.shields.io/pypi/dw/pgraph-python\\\" alt=\\\"pypi downloads\\\">\\n<a href=\\\"https://pypi.python.org/pypi/pgraph-python/\\\"><img src=\\\"https://badge.fury.io/py/pgraph-python.svg\\\" alt=\\\"PyPI version fury.io\\\"></a>\\n<a href=\\\"https://lgtm.com/projects/g/petercorke/pgraph-python/context:python\\\"><img src=\\\"https://img.shields.io/lgtm/grade/python/g/petercorke/pgraph-python.svg?logo=lgtm&amp;logoWidth=18\\\" alt=\\\"Language grade: Python\\\"></a>\\n<a href=\\\"https://pypi.python.org/pypi/pgraph-python/\\\"><img src=\\\"https://img.shields.io/pypi/pyversions/pgraph-python\\\" alt=\\\"PyPI pyversions\\\"></a>\\n<a href=https://github.com/petercorke/pgraph-python/graphs/commit-activity><img src=\\\"https://img.shields.io/badge/Maintained%3F-yes-green.svg\\\" alt=\\\"Maintenance\\\"></a>\\n<a href=https://github.com/petercorke/pgraph-python/blob/master/LICENSE><img src=\\\"https://img.shields.io/github/license/Naereen/StrapDown.js.svg\\\" alt=\\\"GitHub license\\\"></a>\\n<a href=\\\"https://qcr.github.io\\\"><img src=https://github.com/qcr/qcr.github.io/raw/master/misc/badge.svg alt=\\\"QUT Centre for Robotics Open Source\\\"></a></p>\\n<ul>\\n<li>GitHub repository: <a href=https://github.com/petercorke/pgraph-python>https://github.com/petercorke/pgraph-python</a></li>\\n<li>Documentation: <a href=\\\"https://petercorke.github.io/pgraph-python\\\">https://petercorke.github.io/pgraph-python</a></li>\\n<li>Dependencies: <code class=\\\"language-none\\\">numpy</code></li>\\n</ul>\\n<p>This Python package allows the manipulation of directed and non-directed graphs.  Also supports embedded graphs.  It is suitable for graphs with thousands of nodes.</p>\\n<p><img src=https://github.com/petercorke/pgraph-python/raw/master/examples/roads.png alt=\\\"road network\\\"></p>\\n<pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">from pgraph import *\\nimport json\\n\\n# load places and routes\\nwith open('places.json', 'r') as f:\\n    places = json.loads(f.read())\\nwith open('routes.json', 'r') as f:\\n    routes = json.loads(f.read())\\n\\n# build the graph\\ng = UGraph()\\n\\nfor name, info in places.items():\\n    g.add_vertex(name=name, coord=info[&quot;utm&quot;])\\n\\nfor route in routes:\\n    g.add_edge(route[0], route[1], cost=route[2])\\n\\n# plan a path from Hughenden to Brisbane\\np = g.path_Astar('Hughenden', 'Brisbane')\\ng.plot(block=False) # plot it\\ng.highlight_path(p)  # overlay the path\\n</code></pre>\\n<h3>Properties and methods of the graph</h3>\\n<p>Graphs belong to the class <code class=\\\"language-none\\\">UGraph</code> or <code class=\\\"language-none\\\">DGraph</code> for undirected or directed graphs respectively.  The graph is essentially a container for the vertices.</p>\\n<ul>\\n<li>\\n<p><code class=\\\"language-none\\\">g.add_vertex()</code> add a vertex</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.n</code> the number of vertices</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g</code> is an iterator over vertices, can be used as <code class=\\\"language-none\\\">for vertex in g:</code></p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g[i]</code> reference a vertex by its index or name</p>\\n<hr>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.add_edge()</code> connect two vertices</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.edges()</code> all edges in the graph</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.plot()</code> plots the vertices and edges</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.nc</code> the number of graph components, 1 if fully connected</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.component(v)</code> the component that vertex <code class=\\\"language-none\\\">v</code> belongs to</p>\\n<hr>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.path_BFS()</code> breadth-first search</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.path_Astar()</code> A* search</p>\\n<hr>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.adjacency()</code> adjacency matrix</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.Laplacian()</code> Laplacian matrix</p>\\n</li>\\n<li>\\n<p><code class=\\\"language-none\\\">g.incidence()</code> incidence matrix</p>\\n</li>\\n</ul>\\n<h3>Properties and methods of a vertex</h3>\\n<p>Vertices belong to the class <code class=\\\"language-none\\\">UVertex</code> (for undirected graphs) or <code class=\\\"language-none\\\">DVertex</code> (for directed graphs), which are each subclasses of <code class=\\\"language-none\\\">Vertex</code>.</p>\\n<ul>\\n<li><code class=\\\"language-none\\\">v.coord</code> the coordinate vector for embedded graph (optional)</li>\\n<li><code class=\\\"language-none\\\">v.name</code> the name of the vertex (optional)</li>\\n<li><code class=\\\"language-none\\\">v.neighbours()</code> is a list of the neighbouring vertices</li>\\n<li><code class=\\\"language-none\\\">v1.samecomponent(v2)</code> predicate for vertices belonging to the same component</li>\\n</ul>\\n<p>Vertices can be named and referenced by name.</p>\\n<h3>Properties and methods of an edge</h3>\\n<p>Edges are instances of the class <code class=\\\"language-none\\\">Edge</code>.\\nEdges are not referenced by the graph object, each edge references a pair of vertices, and the vertices reference the edges.  For a directed graph only the start vertex of an edge references the edge object, whereas for an undirected graph both vertices reference the edge object.</p>\\n<ul>\\n<li><code class=\\\"language-none\\\">e.cost</code> cost of edge for planning methods</li>\\n<li><code class=\\\"language-none\\\">e.next(v)</code> vertex on edge <code class=\\\"language-none\\\">e</code> that is not <code class=\\\"language-none\\\">v</code></li>\\n<li><code class=\\\"language-none\\\">e.v1</code>, <code class=\\\"language-none\\\">e.v2</code> the two vertices that define the edge <code class=\\\"language-none\\\">e</code></li>\\n</ul>\\n<h2>Modifying a graph</h2>\\n<ul>\\n<li><code class=\\\"language-none\\\">g.remove(v)</code> remove vertex <code class=\\\"language-none\\\">v</code></li>\\n<li><code class=\\\"language-none\\\">e.remove()</code> remove edge <code class=\\\"language-none\\\">e</code></li>\\n</ul>\\n<h2>Subclasing pgraph classes</h2>\\n<p>Consider a user class <code class=\\\"language-none\\\">Foo</code> that we would like to connect using a graph <em>overlay</em>, ie.\\ninstances of <code class=\\\"language-none\\\">Foo</code> becomes vertices in a graph.</p>\\n<ul>\\n<li>Have it subclass either <code class=\\\"language-none\\\">DVertex</code> or <code class=\\\"language-none\\\">UVertex</code> depending on graph type</li>\\n<li>Then place instances of <code class=\\\"language-none\\\">Foo</code> into the graph using <code class=\\\"language-none\\\">add_vertex</code> and create edges as required</li>\\n</ul>\\n<pre class=\\\"language-none\\\"><code class=\\\"language-none\\\">class Foo(UVertex):\\n  # foo stuff goes here\\n  \\nf1 = Foo(...)\\nf2 = Foo(...)\\n\\ng = UGraph() # create a new undirected graph\\ng.add_vertex(f1)\\ng.add_vertex(f2)\\n\\nf1.connect(f2, cost=3)\\nfor f in f1.neighbours():\\n    # say hi to the neighbours\\n</code></pre>\\n<h2>Under the hood</h2>\\n<p>The key objects and their interactions are shown below.</p>\\n<p><img src=https://github.com/petercorke/pgraph-python/raw/master/docs/source/datastructures.png alt=\\\"data structures\\\"></p>\\n<h2>MATLAB version</h2>\\n<p>This is a re-engineered version of <a href=https://github.com/petercorke/spatialmath-matlab/blob/master/PGraph.m>PGraph.m</a> which ships as part of the <a href=https://github.com/petercorke/spatialmath-matlab>Spatial Math Toolbox for MATLAB</a>.  This class is used to support bundle adjustment, pose-graph SLAM and various planners such as PRM, RRT and Lattice.</p>\\n<p>The Python version was designed from the start to work with directed and undirected graphs, whereas directed graphs were a late addition to the MATLAB version.  Semantics are similar but not identical.  In particular the use of subclassing rather than references to\\n<em>user data</em> is encouraged.</p>\\n\",\"name\":\"Graph classes (Python)\",\"type\":\"code\",\"url\":\"https://github.com/petercorke/pgraph-python\",\"image\":\"https://github.com/petercorke/pgraph-python/raw/master/examples/roads.png\",\"src\":\"/content/pgraph-python.md\",\"id\":\"pgraph-python\",\"image_position\":\"center\"}"},"__N_SSG":true}